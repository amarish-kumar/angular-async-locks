// angular-async-locks v0.1.2
// Copyright (c)2014 Boris Kozorovitzky.
// Distributed under MIT license
// https://github.com/BorisKozo/angular-async-locks

angular.module("boriskozo.async-locks",[]).factory("AsyncLockFactory",["$timeout",function(a){"use strict";function b(){return new Date-this.start}function c(){this.lock&&this.lock.leave(this)}var d=0,e=function(){this.queue=[],this.ownerTokenId=null};return e.prototype.createToken=function(a){return{id:d++,isCanceled:!1,callback:a,elapsed:b,start:new Date,lock:this,leave:c}},e.prototype.executeCallback=function(b){a(function(){b.callback(b)},0)},e.prototype.enter=function(a,b){if(!angular.isFunction(a))throw new Error("Callback must be a function");var c=this.createToken(a);if(null===c||void 0===c)throw new Error("Token cannot be null or undefined");return null!==this.ownerTokenId?(this.queue.push(c),b&&(c.timeoutId=setTimeout(function(){c.isCanceled=!0,c.timeoutId=null},b))):(this.ownerTokenId=c.id,this.executeCallback(c)),c},e.prototype.leave=function(a){if(null===a||void 0===a)throw new Error("Token cannot be null or undefined");if(null===this.ownerTokenId)throw new Error("There is no pending token in the lock but received "+JSON.stringify(a));if(this.ownerTokenId!==a.id)throw new Error("Owner token mismatch. Expected "+this.ownerTokenId+" but received "+JSON.stringify(a.id));var b;for(this.ownerTokenId=null;this.queue.length>0;)if(b=this.queue.shift(),b.timeoutId&&clearTimeout(b.timeoutId),!b.isCanceled){this.ownerTokenId=b.id,this.executeCallback(b);break}},e.prototype.stop=function(a){if(null===a||void 0===a)throw new Error("Token cannot be null or undefined");if(null===this.ownerTokenId)throw new Error("There is no pending token in the lock but received "+JSON.stringify(a));if(this.ownerTokenId!==a.id)throw new Error("Owner token mismatch. Expected "+this.ownerTokenId+" but received "+JSON.stringify(a.id));var b;for(b=0;b<this.queue.length;b++)this.queue[b].tokenId&&clearTimeout(this.queue[b].tokenId);this.queue=[],this.ownerTokenId=null},e.prototype.isLocked=function(){return null!==this.ownerTokenId},e}]).service("AsyncLockService",["AsyncLockFactory","$q",function(a,b){"use strict";var c={};this.lock=function(b,d,e){if(!b||"string"!=typeof b)throw new Error("The name must be a non empty string");if(!angular.isFunction(d))throw new Error("Callback must be a function");c[b]||(c[b]=new a);var f=c[b];f.enter(function(a){d(function(){f.leave(a)})},e)},this.lockPromise=function(d,e){if(!d||"string"!=typeof d)throw new Error("The name must be a non empty string");if(!angular.isFunction(e))throw new Error("Callback must be a function");c[d]||(c[d]=new a);var f=b.defer(),g=Array.prototype.slice.call(arguments,2),h=c[d];return h.enter(function(a){e.apply(null,g).then(function(b){f.resolve(b),h.leave(a)},function(b){f.reject(b),h.leave(a)},function(a){f.notify(a)})}),f.promise},this.isLocked=function(a){if(!a||"string"!=typeof a)throw new Error("The name must be a non empty string");return Boolean(c[a]&&c[a].isLocked())}}]);